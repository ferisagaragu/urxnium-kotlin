{
  "functional": {
    "title": "Urxnium Kotlin",
    "description": "Dependency to simplify the functions in Spring Boot, avoiding the handling of POJO Objects",
    "icon": "https://firebasestorage.googleapis.com/v0/b/urxnium-kotlin.appspot.com/o/logo.svg?alt=media&token=15d1a3b7-89af-4e24-9a6f-7b28bd03db2a",
    "version": "2.4.9",
    "bookmarks": [],
    "src": [
      {
        "name": "Request",
        "elements": [
          {
            "name": "to<T>",
            "access": "public",
            "bookmark": "letter-e-circle",
            "description": "Este método convierte los datos proporcionados de un objeto JSON a una entidad del sistema para su mejor uso. Nos ayuda a convertir los ID o UUID a entidades del sistema por medio de su DAO a su vez nos ayuda a que algunos datos del JSON cumplan con las características que necesitamos para persistir la información.",
            "html": null,
            "exampleCodes": [
              {
                "title": "Convierte un JSON en entidad",
                "description": "En el siguiente código se manda a la petición un JSON. El método to nos ayudara a convertirlo en la entidad que nosotros queramos, la única condición es que las key del JSON se llamen igual que los campos de la entidad. Todas aquellas keys que no coincidan con la entidad serán ignoradas.",
                "code": "{\n  \"name\": \"Spider-Man\",\n  \"villain\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\",\n  \"villainId\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\"\n}",
                "out": "fun createHero(hero: Request): Hero {\n  val heroSave = storage.to<Hero>(Hero::class)\n  return heroDAO.save(heroSave)\n}",
                "language": "kotlin"
              },
              {
                "title": "Convierte JSON keys en entidades",
                "description": "En el siguiente código se manda a la petición un JSON en el que la key ‘villain’ viene como un UUID, pero en el sistema es una entidad. El método to nos puede ayudar a hacer una conversión de esta entidad tan solo con decirle que campo, proporcionarle el DAO y decirle que tipo de ID es si ID convencional o UUID.",
                "code": "{\n  \"name\": \"Spider-Man\",\n  \"villainId\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\"\n}",
                "out": "fun createHero(hero: Request): Hero {\n  val heroSave = storage.to<Hero>(\n    Hero::class,\n    EntityParse(\n      \"villainId\",\n      \"villain\"\n      villainDAO,\n      IdType.UUID\n    )\n  )\n\n  return heroDAO.save(heroSave)\n}",
                "language": "kotlin"
              },
              {
                "title": "Valida que el JSON de la petición cumple con los campos y los datos que necesitas",
                "description": "En el siguiente código se manda a la petición un JSON. El método to nos puede ayudar a validar que los datos que necesitamos cumplan con ciertas características y evitarnos hacer esto de manera manual.",
                "code": "{\n  \"name\": \"Spider-Man\",\n  \"villain\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\",\n  \"villainId\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\"\n}",
                "out": "fun createHero(hero: Request): Hero {\n  val heroSave = hero.to<Hero>(\n    Hero::class,\n    Validations(\n      Validation(\n        \"name\",\n        \"Upps the name is required\",\n        ValidationType.NOT_NULL,\n        ValidationType.NOT_BLANK,\n        ValidationType.EXIST\n      )\n    )\n  )\n\n  return heroDAO.save(heroSave)\n}",
                "language": "kotlin"
              },
              {
                "title": "Valida que el JSON de la petición cumple con los campos y los datos que necesitas, si no regrese el mensaje de acuerdo a la tecnología que usas",
                "description": "En el siguiente código se manda a la petición un JSON. También podemos decirle al método to con que tecnología estamos trabajando como lo es GraphQL. De esta manera el las validaciones serán envidas como mensajes válidos para esta tecnología.",
                "code": "{\n  \"name\": \"Spider-Man\",\n  \"villain\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\",\n  \"villainId\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\"\n}",
                "out": "fun createHero(hero: Request): Hero {\n  val heroSave = hero.to<Hero>(\n    Hero::class,\n    Validations(\n      ServiceType.GRAPHQL,\n      Validation(\n        \"name\",\n        \"Upps the name is required\",\n        ValidationType.NOT_NULL,\n        ValidationType.NOT_BLANK,\n        ValidationType.EXIST,\n        ValidationType.TEXT,\n        ValidationType.minLength(5),\n        ValidationType.maxLength(10),\n        ValidationType.pattern(\"[a-zA-Z]+\"),\n        ValidationType.includes(\"Fernando\", \"Isaías\")\n      )\n    )\n  )\n\n  return heroDAO.save(heroSave)\n}",
                "language": "kotlin"
              }
            ],
            "attributes": [
              {
                "name": "kClass",
                "type": "KClass",
                "description": "Esta es la entidad en la que se va a convertir el JSON de la petición.",
                "default": "not null"
              },
              {
                "name": "validations",
                "type": "Validations",
                "description": "La clase Validation nos ayudara a validar los los datos del JSON provenientes de la petición",
                "default": "null"
              },
              {
                "name": "entityParse",
                "type": "vararg<EntityParse>",
                "description": "Los elementos de tipo EntityParse nos ayudaran a buscar y deserializar los ID o UUID provenientes del JSON de la petición",
                "default": "[]"
              }
            ]
          },
          {
            "name": "EntityParse",
            "access": "entity",
            "bookmark": "",
            "description": "This entity helps us to give the necessary information to the to method, so that it can convert a JSON key into an entity",
            "html": null,
            "exampleCodes": [],
            "attributes": [
              {
                "name": "fieldName",
                "type": "String",
                "description": "Name of the field to be searched and serialized",
                "default": "not null"
              },
              {
                "name": "convertFieldName",
                "type": "String",
                "description": "This will be the dress name of the serialized field",
                "default": "''"
              },
              {
                "name": "dao",
                "type": "Any",
                "description": "This is the DAO object that to search for the object to be serialized in the field",
                "default": "not null"
              },
              {
                "name": "idType",
                "type": "IdType",
                "description": "This is the type of id that will be used for the search, either a UUID or a conventional numeric ID",
                "default": "not null"
              }
            ]
          },
          {
            "name": "Validations",
            "access": "entity",
            "bookmark": "",
            "description": "La entidad Validations nos ayuda a indicarle al método to que requisitos debe tener el JSON que queremos serializar en entidad. También con el podemos especificar para que tecnología es el tipo de error que lanzaremos, si el JSON no cumple los requisitos que necesitamos este mandara un error 400 o un error de GraphQL según especifiquemos.",
            "html": null,
            "exampleCodes": [],
            "attributes": [
              {
                "name": "validations",
                "type": "vararg Validation",
                "description": "En este objeto se albergarán las validaciones que queremos para nuestro JSON.",
                "default": "[]"
              },
              {
                "name": "serviceType",
                "type": "ServiceType",
                "description": "Este especifica con qué tipo de tecnología estamos trabajando si es con REST o GraphQL.",
                "default": "ServiceType.REST"
              }
            ]
          },
          {
            "name": "Validation",
            "access": "entity",
            "bookmark": "",
            "description": "Esta entidad nos ayuda a mapear que JSON key es la que queremos validar, que mensaje queremos mandar cuando algo no es como lo requerimos y que validaciones usaremos.",
            "html": null,
            "exampleCodes": [],
            "attributes": [
              {
                "name": "fieldName",
                "type": "String",
                "description": "Nombre del JSON key que queremos validar.",
                "default": "not null"
              },
              {
                "name": "message",
                "type": "String",
                "description": "Mensaje que enviaremos al cliente si la JSON key no cumple con nuestras validaciones.",
                "default": "not null"
              },
              {
                "name": "validationType",
                "type": "MutableList<String>",
                "description": "Validaciones que se le harán a la JSON key.",
                "default": "[]"
              }
            ]
          },
          {
            "name": "ValidationType",
            "access": "entity",
            "bookmark": "",
            "description": "Esta entidad nos ayuda a saber que validaciones aplicaremos en nuestra JSON key dándonos una lista variada de diferentes aspectos que se piensa son los mas comunes al momento de pedir datos para una petición. Lamentablemente puede haber alguna validación que no este en este listado y tendremos que hacerla por nuestra propia cuenta.",
            "html": null,
            "exampleCodes": [],
            "attributes": [
              {
                "name": "NOT_NULL",
                "type": "static String",
                "description": "Indicador para validar que la JSON key no sea nula.",
                "default": "'NOT_NULL'"
              },
              {
                "name": "NOT_BLANK",
                "type": "static String",
                "description": "Indicador para validar que la JSON key no sea vacía.",
                "default": "'NOT_BLANK'"
              },
              {
                "name": "EXIST",
                "type": "static String",
                "description": "Indicador para validar que la JSON key exista.",
                "default": "'EXIST'"
              },
              {
                "name": "TEXT",
                "type": "static String",
                "description": "Indicador para validar que la JSON key sea texto.",
                "default": "'TEXT'"
              },
              {
                "name": "NUMBER",
                "type": "static String",
                "description": "Indicador para validar que la JSON key sea numérica.",
                "default": "'NUMBER'"
              },
              {
                "name": "BOOLEAN",
                "type": "static String",
                "description": "Indicador para validar que la JSON key sea booleana.",
                "default": "'BOOLEAN'"
              },
              {
                "name": "min(Double)",
                "type": "method return String",
                "description": "Método para validar que la JSON key no sea menor de cierto número, solo para datos numéricos.",
                "default": "''"
              },
              {
                "name": "max(Double)",
                "type": "method return String",
                "description": "Método para validar que la JSON key no sea mayor de cierto número, solo para datos numéricos.",
                "default": "''"
              },
              {
                "name": "minLength(Int)",
                "type": "method return String",
                "description": "Método para validar que el texto de la JSON key no sea menor a cierto número.",
                "default": "''"
              },
              {
                "name": "maxLength(Int)",
                "type": "method return String",
                "description": "Método para validar que el texto de la JSON key no sea mayor a cierto número.",
                "default": "''"
              },
              {
                "name": "pattern(String)",
                "type": "method return String",
                "description": "Método para validar que el texto de la JSON key coincide con las reglas regex que queramos.",
                "default": "''"
              },
              {
                "name": "includes(vararg String)",
                "type": "method return String",
                "description": "Método para validar que el texto de la JSON key coincida solo con las palabras que queramos.",
                "default": "''"
              }
            ]
          },
          {
            "name": "ServiceType",
            "access": "enum",
            "bookmark": "",
            "description": "Este enumerado nos ayuda a distinguir como moldear los errores que se puedan causar al validar los datos del JSON entrante, ya sea con el tipo de servicio REST o GraphQL.",
            "html": null,
            "exampleCodes": [],
            "attributes": [
              {
                "name": "REST",
                "type": "REST",
                "description": "Indicador para que la entidad Validations sepa que como moldear el error para un servicio REST. Por defecto esta opción es la seleccionada.",
                "default": "Object"
              },
              {
                "name": "GRAPHQL",
                "type": "GRAPHQL",
                "description": "Indicador para que la entidad Validations sepa que como moldear el error para un servicio GraphQL. ",
                "default": "Object"
              }
            ]
          },
          {
            "name": "IdType",
            "access": "enum",
            "bookmark": "",
            "description": "Este enumerado nos ayuda a distinguir entre los dos tipos de identificadores mas comunes que existen en una base de datos, Diciéndole a la entidad EntityParse por que tipo de identificador debe buscar.",
            "html": null,
            "exampleCodes": [],
            "attributes": [
              {
                "name": "UUID",
                "type": "UUID",
                "description": "Indicador para que el EntityParse sepa que debe buscar por UUID.",
                "default": "Object"
              },
              {
                "name": "ID",
                "type": "ID",
                "description": "Indicador para que el EntityParse sepa que debe buscar por Id.",
                "default": "Object"
              }
            ]
          },
          {
            "name": "merge<T>",
            "access": "public",
            "bookmark": "",
            "description": "Este método convierte los datos proporcionados de un objeto JSON a una entidad y los une con datos ya existentes en el sistema, esto nos ayuda a no generar “sets” para asignar la información éntrate. Tan solo con proporcionar que campo contiene el ID o UUID de la información a modificar, su DAO y que tipo de ID es el que se usara para la búsqueda.",
            "html": null,
            "exampleCodes": [
              {
                "title": "Convierte un JSON en entidad y únela con una que ya exista",
                "description": "En el siguiente código se manda a la petición un JSON. El método merge nos ayudara a convertir la información en entidad y a unir dicha información con una entidad ya existente para generar una actualización en el sistema. Todas aquellas keys que no coincidan con la entidad serán ignoradas.",
                "code": "{\n  \"uid\": \"bb9f3dc7-e277-4d9c-a69a-93ec8aad6539\",\n  \"name\": \"Iron-Man\"\n}",
                "out": "fun createHero(hero: Request): Hero {\n  val heroUpdate = request.merge<Hero>(\n    EntityParse(\n      \"uid\",\n      heroDao,\n      IdType.UUID\n    )\n  )\n\n  return heroDAO.save(heroSave)\n}",
                "language": "javascript"
              },
              {
                "title": "Valida que el JSON de la petición cumple con los campos y los datos que necesitas",
                "description": "En el siguiente código se manda a la petición un JSON. El método merge nos puede ayudar a validar que los datos que necesitamos cumplan con ciertas características y evitarnos hacer esto de manera manual.",
                "code": "{\n  \"uid\": \"bb9f3dc7-e277-4d9c-a69a-93ec8aad6539\",\n  \"name\": \"Iron-Man\"\n}",
                "out": "fun createHero(hero: Request): Hero {\n  val heroUpdate = request.merge<Hero>(\n    EntityParse(\n      \"uid\",\n      heroDao,\n      IdType.UUID\n    ),\n    Validations(\n      ServiceType.GRAPHQL,\n      Validation(\n        \"name\",\n        \"Upps the name is required\",\n        ValidationType.NOT_NULL,\n        ValidationType.NOT_BLANK,\n        ValidationType.EXIST,\n        ValidationType.TEXT,\n        ValidationType.minLength(5),\n        ValidationType.maxLength(10),\n        ValidationType.pattern(\"[a-zA-Z]+\"),\n        ValidationType.includes(\"Fernando\", \"Isaías\")\n      )\n    )\n  )\n\n  return heroDAO.save(heroSave)\n}",
                "language": "javascript"
              }
            ],
            "attributes": [
              {
                "name": "entityParse",
                "type": "EntityParse",
                "description": "Con esta clase vamos a especificar los objetos con los que buscaremos el objeto de nuestra entidad",
                "default": "not-null"
              },
              {
                "name": "validations",
                "type": "Validations",
                "description": "La clase Validation nos ayudara a validar los los datos del JSON provenientes de la petición",
                "default": "null"
              }
            ]
          },
          {
            "name": "validate",
            "access": "public",
            "bookmark": "",
            "description": "En ocasiones puede que el JSON entrante a nuestro servicio no se pueda serializar en ninguno de nuestras entidades, la función ‘validate’ nos ayuda a poder hacer validaciones de igual manera que el método ‘to’, sin hacer una convención a entidad.",
            "html": null,
            "exampleCodes": [
              {
                "title": "Valida que el JSON de la petición cumple con los campos y los datos que necesitas",
                "description": "En el siguiente código se manda a la petición un JSON. El método to nos puede ayudar a validar que los datos que necesitamos cumplan con ciertas características y evitarnos hacer esto de manera manual.",
                "code": "{\n  \"uid\": \"bb9f3dc7-e277-4d9c-a69a-93ec8aad6539\",\n  \"name\": \"Spider\",\n  \"rescuePerson\": 5\n}",
                "out": "fun saveHeroes(request: Request): ResponseEntity<Any> {\n  request.validate(\n    Validations(\n      Validation(\n        \"heroName\",\n        \"Upps el nombre del super heroe no es valido\",\n        ValidationType.NOT_NULL,\n        ValidationType.NOT_BLANK,\n        ValidationType.includes(\"spider\", \"cat\", \"lizard\")\n      ),\n      Validation(\n        \"rescuePerson\",\n        \"Upps las personas rescatadas no son validas\",\n        ValidationType.NOT_NULL,\n        ValidationType.NOT_BLANK,\n        ValidationType.NUMBER\n      )\n    )\n  )\n}",
                "language": "javascript"
              }
            ],
            "attributes": [
              {
                "name": "validations",
                "type": "Validations",
                "description": "La clase Validation nos ayudara a validar los los datos del JSON provenientes de la petición",
                "default": null
              }
            ]
          },
          {
            "name": "toList<T>",
            "access": "public",
            "bookmark": "",
            "description": "Este método nos ayuda a convertir la KEY de un JSON en una lista de peticiones controlada, dándonos así las mismas funciones que nos otorga el método ‘to’, dándonos la oportunidad de validar y convertir datos de manera masiva.",
            "html": null,
            "exampleCodes": [
              {
                "title": "Convierte JSON keys en entidades",
                "description": "En el siguiente código se manda a la petición un Array JSON. El método toList nos ayudara a convertirlo en la lista de entidades que nosotros queramos, la única condición es que las key del JSON se llamen igual que los campos de la entidad. Todas aquellas keys que no coincidan con la entidad serán ignoradas.",
                "code": "[\n  {\n    \"name\": \"Spider-Man\",\n    \"villain\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\",\n    \"villainId\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\"\n  },{\n    \"name\": \"Magneto\",\n    \"villain\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\",\n    \"villainId\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\"\n  }\n]",
                "out": "fun createHero(hero: Request) {\n  val heroes = storage.toList<Hero>(Hero::class)\n  \n  heroes.forEach { hero -> println(hero.name) }\n}",
                "language": "javascript"
              },
              {
                "title": "Convierte JSON keys en entidades",
                "description": "En el siguiente código se manda a la petición un JSON en el que la key ‘villain’ viene como un UUID, pero en el sistema es una entidad. El método toList nos puede ayudar a hacer una conversión de esta entidad tan solo con decirle que campo, proporcionarle el DAO y decirle que tipo de ID es si ID convencional o UUID.",
                "code": "[\n  {\n    \"name\": \"Spider-Man\",\n    \"villainId\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\"\n  },{\n    \"name\": \"Magneto\",\n    \"villainId\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\"\n  }\n]",
                "out": "fun createHero(hero: Request) {\n  val heroes = storage.toList<Hero>(\n    Hero::class,\n    EntityParse(\n      \"villainId\",\n      \"villain\"\n      villainDAO,\n      IdType.UUID\n    )\n  )\n\n  heroes.forEach { hero -> heroDAO.save(heroSave) }\n}",
                "language": "javascript"
              },
              {
                "title": "Valida que el JSON de la petición cumple con los campos y los datos que necesitas",
                "description": "En el siguiente código se manda a la petición un JSON. El método toList nos puede ayudar a validar que los datos que necesitamos cumplan con ciertas características y evitarnos hacer esto de manera manual.",
                "code": "[\n  {\n    \"name\": \"Spider-Man\",\n    \"villainId\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\"\n  },{\n    \"name\": \"Magneto\",\n    \"villainId\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\"\n  }\n]",
                "out": "fun createHero(hero: Request) {\n  val heroes = storage.toList<Hero>(\n    Hero::class,\n    Validations(\n      Validation(\n        \"name\",\n        \"Upps the name is required\",\n        ValidationType.NOT_NULL,\n        ValidationType.NOT_BLANK,\n        ValidationType.EXIST\n      )\n    )\n  )\n\n  heroes.forEach { hero -> heroDAO.save(heroSave) }\n}",
                "language": "javascript"
              },
              {
                "title": "Valida que el JSON de la petición cumple con los campos y los datos que necesitas, si no regrese el mensaje de acuerdo a la tecnología que usas",
                "description": "En el siguiente código se manda a la petición un JSON. También podemos decirle al método toList con que tecnología estamos trabajando como lo es GraphQL. De esta manera el las validaciones serán envidas como mensajes válidos para esta tecnología.",
                "code": "[\n  {\n    \"name\": \"Spider-Man\",\n    \"villainId\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\"\n  },{\n    \"name\": \"Magneto\",\n    \"villainId\": \"83b824dd-8c7e-480c-a68c-729f8365d5f3\"\n  }\n]",
                "out": "fun createHero(hero: Request) {\n  val heroes = storage.toList<Hero>(\n    Hero::class,\n    Validations(\n      ServiceType.GRAPHQL,\n      Validation(\n        \"name\",\n        \"Upps the name is required\",\n        ValidationType.NOT_NULL,\n        ValidationType.NOT_BLANK,\n        ValidationType.EXIST,\n        ValidationType.TEXT,\n        ValidationType.minLength(5),\n        ValidationType.maxLength(10),\n        ValidationType.pattern(\"[a-zA-Z]+\"),\n        ValidationType.includes(\"Fernando\", \"Isaías\")\n      )\n    )\n  )\n\n  heroes.forEach { hero -> heroDAO.save(heroSave) }\n}",
                "language": "javascript"
              }
            ],
            "attributes": [
              {
                "name": "kClass",
                "type": "KClass",
                "description": "Esta es la entidad en la que se va a convertir el JSON de la petición.",
                "default": "not null"
              },
              {
                "name": "validations",
                "type": "Validations",
                "description": "La clase Validation nos ayudara a validar los los datos del JSON provenientes de la petición",
                "default": "null"
              },
              {
                "name": "entityParse",
                "type": "vararg<EntityParse>",
                "description": "Los elementos de tipo EntityParse nos ayudaran a buscar y deserializar los ID o UUID provenientes del JSON de la petición",
                "default": "[]"
              }
            ]
          },
          {
            "name": "toRequest",
            "access": "public",
            "bookmark": "",
            "description": "Este método nos ayuda a convertir un objeto, en uno Request. Normalmente el objeto Request proviene de una petición REST, pero también podemos usarlo para validar, Mapas o texto que sabemos que es un JSON valido",
            "html": null,
            "exampleCodes": [
              {
                "title": "Convierte un objeto en Request",
                "description": "A continuación, se muestra como podemos convertir texto que sabemos que es un JSON valido en un objeto Request.",
                "code": "{\n  \"uuid\": \"983d5f02-7bcf-4e47-928c-10f6bfb02299\",\n  \"name\": \"Spider-Man\"\n}",
                "out": "fun createHero(heroJSON: String) {\n  val request = Request().toRequest(hero)\n}",
                "language": "javascript"
              }
            ],
            "attributes": [
              {
                "name": "json",
                "type": "String",
                "description": "Texto que sabemos que es un objeto JSON valido.",
                "default": "not null"
              },
              {
                "name": "linkedHashMap",
                "type": "LinkedHashMap<String, Any>",
                "description": "Mapa que queremos convertir a Request.",
                "default": "not null"
              }
            ]
          }
        ]
      },
      {
        "name": "Documentation",
        "elements": [
          {
            "name": "@Bean Documentation",
            "access": "component",
            "bookmark": "",
            "description": "Este componente nos ayuda a tener una interface visual para los servicios que hagamos en Spring Boot, ya que nos un entorno embebido de \"Urxnium Doc\", el cual viene preparado para ayudarnos a documentar nuestros servicios con la menor cantidad de información posible.",
            "html": null,
            "exampleCodes": [
              {
                "title": "Añade el Urxnium Doc a tu proyecto Spring Boot",
                "description": "",
                "code": "@Bean\nfun documentation(): Documentation {\n  val bodyRequest = LinkedHashMap<String, String>()\n  bodyRequest[\"userName\"] = \"fake.mail@fake.com\"\n  bodyRequest[\"password\"] = \"fakepassword\"\n\n  return Documentation(\n    ApiInfo(\n      title = \"Nombre de tu aplicacion\",\n      description = \"La description de tu api\",\n      iconUrl = \"\",\n      version = \"0.0.1\",\n      credentials = listOf(\n        Credential(\n          name = \"El nombre de tu credencial\",\n          endPoint = \"Aquí va el end point que genera el token de autenticación\",\n          bodyRequest = bodyRequest,\n          tokenMapping = \"data.session.token <- mapea en donde debe buscar Urxnium Doc el token de autenticación\"\n        )\n      )\n    ),\n    Controller1::class,\n    Controller2::class\n  )\n}",
                "out": null,
                "language": "javascript"
              },
              {
                "title": "Como ver la documentación de mis servicios",
                "description": "Una ves hayas inyectado las dependencias en Spring Boot y le hayas dicho a Urxnium Doc que clases debe documentar, es momento de poder visualizar tus resultados los cuales podrás observar en la siguiente dirección.",
                "code": "http://TU_HOST/rest/auth",
                "out": null,
                "language": "shell"
              }
            ],
            "attributes": [
              {
                "name": "title",
                "type": "String",
                "description": "Nombre de la aplicación",
                "default": "\"\""
              },
              {
                "name": "description",
                "type": "String",
                "description": "Descripción de la aplicación",
                "default": "\"\""
              },
              {
                "name": "iconUrl",
                "type": "String",
                "description": "Url del icono de la aplicación",
                "default": "\"\""
              },
              {
                "name": "version",
                "type": "String",
                "description": "Versión del Api REST",
                "default": "\"\""
              },
              {
                "name": "baseUrl",
                "type": "String",
                "description": "Url base, sobre el que corre la aplicación",
                "default": "\"\""
              }
            ]
          },
          {
            "name": "@ApiDocumentation",
            "access": "interface",
            "bookmark": "",
            "description": "Esta anotación nos ayuda a poder crear una documentación más precisa. A pesar de que Urxnium Doc puede ayudarnos a documentar un servicio, con frecuencia se necesita más que una documentación básica y hay que ser más específicos para que se entienda el funcionamiento total, del servicio REST, @ApiDocument nos ayudara a indicarle a Urxnium Doc de donde puede sacar esta información extra para dejar un servicio REST más entendible para otros desarrolladores.",
            "html": null,
            "exampleCodes": [
              {
                "title": "Crea un archivo de documentación personalizado",
                "description": "Para documentar de una manera mas precisa, hay que crear un archivo de tipo JSON, donde le indicaremos a Urxnium Doc lo que queremos que muestre a otros desarrolladores en pantalla. Para esto se a colocado el archivo de documentación en la carpeta api/demo/demo-doc.json. ¿Por que la documentación esta en un archivo por separado? Para Pechblenda y Urxnium Kotlin, es muy importante mantener el código de programación 100% legible, por esta misma razón en vez de llenar el servicio de anotaciones como otras dependencias de documentación, preferimos separarlas en archivos unicos para de esta manera tener el código mas legible, ademas de poder encontrar la documentación de dicho servicio de manera mas sencilla.",
                "code": "project\n  └──src\n      │──kotlin\n      └──resources\n          └──api\n              └──demo\n                  └──demo-doc.json",
                "out": null,
                "language": "shell"
              },
              {
                "title": "Llena la documentación de manera mas detallada",
                "description": "Para ser más detallados al documentar nuestra aplicación, Urxnium Doc puede leer la siguiente sintaxis dentro de un archivo JSON. Cada una de las keys que presenta este archivo pueden ser removibles si no son necesarias.",
                "code": "{\n  \"description\": \"Servicio para registrar un nuevo usuario\", //Esta es la descripcion del servicio\n  \"authorization\": true, //Indica si va a ser necesario mostrar la interface de authorizacion en el servicio\n  \"responseOk\": { }, //Puede ser cualquier tipo de JSON o ARRAY\n  \"responseBadRequest\": { }, //Puede ser cualquier tipo de JSON o ARRAY,\n  \"responseInternalServerError\": { }, //Puede ser cualquier tipo de JSON o ARRAY,\n  \"requestBody\": { }, //Puede ser cualquier tipo de JSON o ARRAY. Tambien es un JSON de muestra para hacer la petición\n  \"pathVariables | pathParams\": [ //Mapeo de las variables de ruta\n    { \n      \"name\": \"param demo\",\n      \"value\": \"\",\n      \"type\": \"text\",\n      \"value\": \"9bb5bd86-a01c-4eab-a7eb-a9d17f5f18fa\",\n      \"required\": true\n    }\n  ]\n}",
                "out": null,
                "language": "javascript"
              }
            ],
            "attributes": [
              {
                "name": "path",
                "type": "String",
                "description": "Ruta del archivo de documentación",
                "default": "\"\""
              }
            ]
          },
          {
            "name": "Inyección de Componentes",
            "access": "component",
            "bookmark": "",
            "description": "Urxnium Kotlin nos ofrece funcionalidades agregadas para el framework Spring Boot, pero antes de poder utilizarlas hay decirle a Spring Boot donde debe buscar, para que todas nuestras funcionalidades sean @Beans inyectables en nuestra aplicación.",
            "html": null,
            "exampleCodes": [
              {
                "title": "Inyecta los componentes de Urxnium Kotlin en Spring Boot",
                "description": "Hacer la inyección de los componentes de Urxnium Kotlin es muy fácil, pero también es un paso super importante para que todos los componentes que te ofrecemos funcionen de manera correcta.",
                "code": "@Configuration\n@ComponentScan(\"org.pechblenda.bean\")\nclass BeanConfig",
                "out": null,
                "language": "javascript"
              }
            ],
            "attributes": []
          }
        ]
      },
      {
        "name": "Color",
        "elements": [
          {
            "name": "CategoryColor",
            "access": "enum",
            "bookmark": "",
            "description": "El enumerado CategoryColor nos ayudara a definir entre diferentes opciones que gama de colores de Material Design queremos para que el color al azar sea dentro de la misma.",
            "html": null,
            "attributes": [
              {
                "name": "MATERIAL_50",
                "type": "Object",
                "description": "Gama de colores de Material Design.",
                "default": "not null"
              },
              {
                "name": "MATERIAL_100",
                "type": "Object",
                "description": "Gama de colores de Material Design.",
                "default": "not null"
              },
              {
                "name": "MATERIAL_200",
                "type": "Object",
                "description": "Gama de colores de Material Design.",
                "default": "not null"
              },
              {
                "name": "MATERIAL_300",
                "type": "Object",
                "description": "Gama de colores de Material Design.",
                "default": "not null"
              },
              {
                "name": "MATERIAL_400",
                "type": "Object",
                "description": "Gama de colores de Material Design.",
                "default": "not null"
              },
              {
                "name": "MATERIAL_500",
                "type": "Object",
                "description": "Gama de colores de Material Design.",
                "default": "not null"
              },
              {
                "name": "MATERIAL_600",
                "type": "Object",
                "description": "Gama de colores de Material Design.",
                "default": "not null"
              },
              {
                "name": "MATERIAL_700",
                "type": "Object",
                "description": "Gama de colores de Material Design.",
                "default": "not null"
              },
              {
                "name": "MATERIAL_800",
                "type": "Object",
                "description": "Gama de colores de Material Design.",
                "default": "not null"
              },
              {
                "name": "MATERIAL_900",
                "type": "Object",
                "description": "Gama de colores de Material Design.",
                "default": "not null"
              },
              {
                "name": "MATERIAL_A100",
                "type": "Object",
                "description": "Gama de colores de Material Design.",
                "default": "not null"
              },
              {
                "name": "MATERIAL_A200",
                "type": "Object",
                "description": "Gama de colores de Material Design.",
                "default": "not null"
              },
              {
                "name": "MATERIAL_A400",
                "type": "Object",
                "description": "Gama de colores de Material Design.",
                "default": "not null"
              },
              {
                "name": "MATERIAL_A700",
                "type": "Object",
                "description": "Gama de colores de Material Design.",
                "default": "not null"
              },
              {
                "name": "ALL",
                "type": "Object",
                "description": "Todas las gamas de colores de Material Design.",
                "default": "not null"
              }
            ]
          }
        ]
      },
      {
        "name": "Report",
        "elements": [
          {
            "name": "exportPdf",
            "access": "public",
            "bookmark": "",
            "description": "Este método nos ayuda a compilar y generar un PDF de salida compilando un archivo de JasperReports.",
            "html": "Te recomendamos utilices la herramienta de <a href=\"https://sourceforge.net/projects/jasperstudio/files/JaspersoftStudio-6.16.0/\" target=\"_blank\">JasperReports Studio en su versión 6.16.0</a> ya que es con la que se testeó Urxnium Kotlin.",
            "exampleCodes": [
              {
                "title": "Convierte un archivo .jrxml a un reporte compatible con Spring Boot",
                "description": "Hoy en día es muy común que los servicios web generen reportes detallados de la información del sistema, con ayuda de Urxnium podemos hacer fácilmente la compilación y creación de reportes para que en pocas líneas lo logremos y así solo preocuparnos por obtener la información.",
                "code": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!-- Created with Jaspersoft Studio version 6.16.0.final using JasperReports Library version 6.16.0-48579d909b7943b64690c65c71e07e0b80981928  -->\n<jasperReport xmlns=\"http://jasperreports.sourceforge.net/jasperreports\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://jasperreports.sourceforge.net/jasperreports http://jasperreports.sourceforge.net/xsd/jasperreport.xsd\" name=\"tiket\" pageWidth=\"595\" pageHeight=\"842\" columnWidth=\"555\" leftMargin=\"20\" rightMargin=\"20\" topMargin=\"20\" bottomMargin=\"20\" uuid=\"5e945d8c-3f04-4724-9ca3-13d82ba24fad\">\n\t<parameter name=\"background\" class=\"java.io.InputStream\"/>\n\n\t<field name=\"name\" class=\"java.lang.String\">\n\t\t<property name=\"net.sf.jasperreports.json.field.expression\" value=\"name\"/>\n\t\t<fieldDescription><![CDATA[name]]></fieldDescription>\n\t</field>\n\n\t<background>\n\t\t<band splitType=\"Stretch\"/>\n\t</background>\n\n\t<detail>\n\t\t<band height=\"197\" splitType=\"Stretch\">\n\t\t\t<image>\n\t\t\t\t<reportElement x=\"111\" y=\"0\" width=\"360\" height=\"195\" uuid=\"0c69c389-4b98-4a87-9c0a-8554725fd2c4\">\n\t\t\t\t\t<property name=\"com.jaspersoft.studio.unit.height\" value=\"pixel\"/>\n\t\t\t\t</reportElement>\n\n\t\t\t\t<box topPadding=\"0\" leftPadding=\"0\" rightPadding=\"0\"/>\n\n\t\t\t\t<imageExpression><![CDATA[$P{background}]]></imageExpression>\n\t\t\t</image>\n\n\t\t\t<textField>\n\t\t\t\t<reportElement x=\"164\" y=\"80\" width=\"260\" height=\"15\" uuid=\"5dfc52e2-c1d0-46c0-a69e-e764059bbeaa\">\n\t\t\t\t\t<property name=\"com.jaspersoft.studio.unit.height\" value=\"px\"/>\n\t\t\t\t</reportElement>\n\n\t\t\t\t<textElement textAlignment=\"Center\" verticalAlignment=\"Middle\">\n\t\t\t\t\t<font fontName=\"Josefin Sans\"/>\n\t\t\t\t</textElement>\n\n\t\t\t\t<textFieldExpression><![CDATA[$F{name}]]></textFieldExpression>\n\t\t\t</textField>\n\t\t</band>\n\t</detail>\n</jasperReport>\n",
                "out": "fun superHeroesPDF(): InputStreamResource {\n  val parameters = mutableMapOf<String, Any>()\n  val fields = mutableListOf<MutableMap<String, Any>>()\n  val heroOne = mutableMapOf<String, Any>()\n  val heroTow = mutableMapOf<String, Any>()\n  \n  heroOne[\"name\"] = \"Tony Stark\"\n  heroTow[\"name\"] = \"Petter Parker\"\n  parameters[\"background\"] = ClassPathResource(\"template/report/background.png\").inputStream\t\n\t\n  fields.add(heroOne)\n  fields.add(heroTow)\n\n  return report.exportPdf(\n    ClassPathResource(\"template/report/heroes_report.jrxml\").inputStream,\n    parameters,\n    fields.toMutableList()\n  )\n}",
                "language": "javascript"
              },
              {
                "title": "¿Cómo puedo agregar otros tipos de letras?",
                "description": "Después de una ardua investigación en Urxnium y con la ayuda de JasperReports te mostraremos cómo integrar diferentes tipos de letras de manera fácil. Primero tienes que generar la siguiente estructura en tus recursos, para que JasperReports pueda vincularlas con tu reporte.",
                "code": "> project\n  └──src\n      │──kotlin\n      └──resources\n          │──fonts.jrxml\n          └──font\n              │──your-font-Bold.ttf\n              │──your-font-BoldItalic.ttf\n              │──your-font-Italic.ttf\n              └──your-font-Regular.ttf",
                "out": null,
                "language": "shell"
              },
              {
                "title": "Configurando el archivo de rutas para los fondos",
                "description": "Por último luego de añadir nuestro tipo de letra y sus variantes hay que indicarle a JasperReports donde están y para eso necesitaremos el siguiente archivo, una vez todo en su lugar todo estará listo para funcionar.",
                "code": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<fontFamilies>\n    <fontFamily name=\"fond name\">\n        <normal><![CDATA[font/josefin-sans/JosefinSans-Regular.ttf]]></normal>\n        <bold><![CDATA[font/josefin-sans/JosefinSans-Bold.ttf]]></bold>\n        <italic><![CDATA[font/josefin-sans/JosefinSans-Italic.ttf]]></italic>\n        <bolditalic><![CDATA[font/josefin-sans/JosefinSans-BoldItalic.ttf]]></bolditalic>\n        <pdfEmbedded><![CDATA[true]]></pdfEmbedded>\n        <exportFonts/>\n    </fontFamily>\n</fontFamilies>",
                "out": null,
                "language": "javascript"
              }
            ],
            "attributes": [
              {
                "name": "report",
                "type": "InputStream",
                "description": "Path del archivo .jrxml para ser transformado en PDF",
                "default": "not null"
              },
              {
                "name": "params",
                "type": "MutableMap<String, Any>",
                "description": "Parámetros que el reporte puede tener fondos, títulos, tamaños, etc.",
                "default": "optional"
              },
              {
                "name": "data",
                "type": "MutableList<Any>",
                "description": "Datos que se mostrarán en el PDF",
                "default": "not null"
              }
            ]
          }
        ]
      }
    ]
  }
}